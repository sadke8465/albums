<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Now Playing | Noamsadi95</title>
    <style>
        :root {
            --transition-speed: 10s;
            /* Zoom speed (kept as user req) */
            --zoom-curve: cubic-bezier(0.7, 0, 0.3, 1);
            --fade-speed: 1.5s;
            --fade-curve: cubic-bezier(0.4, 0, 0.2, 1);
            /* Nice smooth curve */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #111;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Ambient Background Wrapper */
        #ambient-bg {
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            z-index: -1;
            /* Container scales */
            transform: scale(1.1);
        }

        /* Background Layers */
        .bg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(80px) brightness(0.7);
            opacity: 0;
            transition: opacity var(--fade-speed) var(--fade-curve);
            will-change: opacity;
        }

        #ambient-bg.hidden {
            /* Hide the whole container during zoom out if needed, 
                but logic says we only hide bg when zoomed IN. */
            opacity: 0;
            transition: opacity var(--transition-speed) var(--zoom-curve);
        }

        /* Container */
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* Album Art */
        .album-art-wrapper {
            width: 85vmin;
            height: 85vmin;
            max-width: 85vw;
            max-height: 85vh;
            border-radius: 7px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform-origin: center center;
            transition: transform var(--transition-speed) var(--zoom-curve), border-radius var(--transition-speed) var(--zoom-curve);
            will-change: transform, border-radius;
            /* Relative positioning for children absolute */
            position: relative;
            background: #000;

            /* Apply Base Scale (Correction for CRT) */
            /* Default transform is scale(1.33, 1) to widen image */
            transform: scale(var(--base-scale-x, 1), var(--base-scale-y, 1));
        }

        /* Zoom States */
        /* 
           Logic: Align Album Corner to Screen Corner exactly.
           Variables --zoom-x and --zoom-y are calculated in JS.
           
           TL: Move Right/Down (+x, +y)
           TR: Move Left/Down (-x, +y)
           BR: Move Left/Up (-x, -y)
           BL: Move Right/Up (+x, -y)
        */
        .album-art-wrapper.zoom-tl {
            transform: translate(var(--zoom-x), var(--zoom-y)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        .album-art-wrapper.zoom-tr {
            transform: translate(calc(var(--zoom-x) * -1), var(--zoom-y)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        .album-art-wrapper.zoom-br {
            transform: translate(calc(var(--zoom-x) * -1), calc(var(--zoom-y) * -1)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        .album-art-wrapper.zoom-bl {
            transform: translate(var(--zoom-x), calc(var(--zoom-y) * -1)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        /* Remove radius when zoomed to look like full bleed image */
        .album-art-wrapper[class*="zoom-"] {
            border-radius: 0;
        }

        .art-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: inherit;
            opacity: 0;
            transition: opacity var(--fade-speed) var(--fade-curve);
            will-change: opacity;
        }

        /* Loading State */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 3px solid #FFF;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        .loader::after {
            content: '';
            box-sizing: border-box;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-bottom-color: #FF3D00;
        }

        @keyframes rotation {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Calibration Overlay */
        #calibration-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0f0;
            color: #0f0;
            padding: 15px;
            font-family: monospace;
            z-index: 9999;
            border-radius: 5px;
            pointer-events: none;
        }

        #calibration-overlay.hidden {
            display: none;
        }

        .calib-box h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
        }

        .calib-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            min-width: 200px;
        }

        .calib-hint {
            margin-top: 10px;
            font-size: 0.8em;
            color: #aaa;
        }
    </style>
</head>

<body>

    <div class="loading" id="loading-screen">
        <h1 style="color: #444; font-family: monospace; letter-spacing: 5px;">VERSION 5.0</h1>
    </div>

    <!-- Calibration Overlay -->
    <div id="calibration-hint"
        style="position:fixed; bottom:20px; left:50%; transform:translateX(-50%); color:#555; font-family:monospace; z-index:9000; opacity:0; transition:opacity 2s;">
        Press 'C' to Calibrate
    </div>

    <div id="calibration-overlay" class="hidden">
        <div class="calib-box">
            <h3>CRT CALIBRATION</h3>
            <div class="calib-row"><span>POS X (Arrows):</span> <span id="val-x">0</span></div>
            <div class="calib-row"><span>POS Y (Arrows):</span> <span id="val-y">0</span></div>
            <div class="calib-row"><span>WIDTH (Shift+L/R):</span> <span id="val-w">1.33</span></div>
            <div class="calib-row"><span>SIZE (Shift+U/D):</span> <span id="val-s">0.85</span></div>
            <p class="calib-hint">Press 'C' to Close & Save</p>
        </div>
    </div>

    <div id="ambient-bg">
        <div id="bg-layer-0" class="bg-layer"></div>
        <div id="bg-layer-1" class="bg-layer"></div>
    </div>

    <div class="container">
        <div class="album-art-wrapper">
            <img id="art-layer-0" class="art-layer" src="" alt="Album Art">
            <img id="art-layer-1" class="art-layer" src="" alt="Album Art">
        </div>
    </div>

    <script>
        const API_KEY = 'f12a1d5a9aad4c0d570403a0aabc9f61';
        const USERNAME = 'Noamsadi95';
        const URL = `https://ws.audioscrobbler.com/2.0/?method=user.getRecentTracks&user=${USERNAME}&api_key=${API_KEY}&format=json&limit=1`;

        const CACHE = {
            id: null, // Artist + Track string
            image: null
        };

        let zoomState = 0; // 0: Default, 1: TL, 2: TR, 3: BR, 4: BL

        const els = {
            bgWrapper: document.getElementById('ambient-bg'),
            bgLayers: [
                document.getElementById('bg-layer-0'),
                document.getElementById('bg-layer-1')
            ],
            wrapper: document.querySelector('.album-art-wrapper'),
            artLayers: [
                document.getElementById('art-layer-0'),
                document.getElementById('art-layer-1')
            ],
            loading: document.getElementById('loading-screen')
        };

        // State for Dual Buffering
        let activeLayerIndex = 0; // The layer currently visible (opacity 1)

        // Init: Ensure layer 0 is top
        if (els.bgLayers[0] && els.artLayers[0]) {
            els.bgLayers[0].style.zIndex = 2;
            els.bgLayers[1].style.zIndex = 1;
            els.artLayers[0].style.zIndex = 2;
            els.artLayers[1].style.zIndex = 1;
        }

        // Zoom Logic
        // Automatically advance. 
        // Logic: 12s for quadrants (states 1-4), 36s for full album (state 0).

        // --- Calibration Mode ---
        let calibrationMode = false;

        // Default Config (V5.1 optimized) - Per View
        const DEFAULT_CONFIG = {
            version: 3,
            views: {
                default: { scaleX: 1.25, scaleY: 1, nudgeX: 0, nudgeY: 0, sizeFactor: 0.95 },
                tl: { scaleX: 1.8, scaleY: 1.8, nudgeX: 0, nudgeY: 0, zoom: 1.8 },
                tr: { scaleX: 1.8, scaleY: 1.8, nudgeX: 0, nudgeY: 0, zoom: 1.8 },
                br: { scaleX: 1.8, scaleY: 1.8, nudgeX: 0, nudgeY: 0, zoom: 1.8 },
                bl: { scaleX: 1.8, scaleY: 1.8, nudgeX: 0, nudgeY: 0, zoom: 1.8 }
            }
        };

        let config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));

        // WebSocket Connection for Live Updates
        let ws = null;

        // Check URL parameters for WebSocket server address
        // Usage: index.html?server=192.168.1.100:8080
        const urlParams = new URLSearchParams(window.location.search);
        const serverParam = urlParams.get('server');
        const WS_URL = serverParam ? `ws://${serverParam}` : 'ws://localhost:8080';

        console.log(`ðŸ”Œ WebSocket URL: ${WS_URL}`);

        function connectWebSocket() {
            try {
                ws = new WebSocket(WS_URL);

                ws.onopen = () => {
                    console.log('âœ“ Connected to control panel server');
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'init') {
                        // Full config update
                        config = data.config;
                        updateZoomCalculations();
                        updateOverlay();
                        console.log('âœ“ Configuration loaded from server');
                    }

                    if (data.type === 'update') {
                        // Single view update
                        if (config.views[data.view]) {
                            config.views[data.view] = {
                                ...config.views[data.view],
                                ...data.settings
                            };
                            updateZoomCalculations();
                            updateOverlay();
                        }
                    }
                };

                ws.onclose = () => {
                    console.log('âœ— Disconnected from control panel');
                    ws = null;
                    // Try to reconnect after 5 seconds
                    setTimeout(connectWebSocket, 5000);
                };

                ws.onerror = () => {
                    console.log('âš ï¸ WebSocket connection failed, using local config');
                };
            } catch (error) {
                console.log('âš ï¸ WebSocket not available, using local config');
            }
        }

        // Helper to get current view config
        function getCurrentViewConfig() {
            const viewMap = ['default', 'tl', 'tr', 'br', 'bl'];
            const viewKey = viewMap[zoomState];
            return config.views[viewKey] || config.views.default;
        }

        // Load Config from localStorage (fallback)
        try {
            const saved = localStorage.getItem('crt_config');
            if (saved) {
                const parsed = JSON.parse(saved);
                // Only use saved if version matches, else reset to new defaults
                if (parsed.version === DEFAULT_CONFIG.version) {
                    config = JSON.parse(JSON.stringify(parsed));
                }
            }
        } catch (e) { }

        // Try to connect to WebSocket server
        connectWebSocket();

        const overlay = document.getElementById('calibration-overlay');
        const uiX = document.getElementById('val-x');
        const uiY = document.getElementById('val-y');
        const uiW = document.getElementById('val-w');
        const uiS = document.getElementById('val-s');

        function updateOverlay() {
            const viewConfig = getCurrentViewConfig();
            uiX.innerText = viewConfig.nudgeX || 0;
            uiY.innerText = viewConfig.nudgeY || 0;
            uiW.innerText = (viewConfig.scaleX || 1).toFixed(2);
            uiS.innerText = (viewConfig.sizeFactor || 0.95).toFixed(2);
        }

        // CSS Variables for Zoom - Now per-view
        function updateZoomCalculations() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;

            // Get default view config for base settings
            const defaultView = config.views.default;
            const HORIZONTAL_SCALE = defaultView.scaleX || 1.25;
            const NUDGE_X = defaultView.nudgeX || 0;
            const NUDGE_Y = defaultView.nudgeY || 0;
            const sizeFactor = defaultView.sizeFactor || 0.95;

            // Get zoom view configs (TL, TR, BR, BL)
            const tlView = config.views.tl;
            const trView = config.views.tr;
            const brView = config.views.br;
            const blView = config.views.bl;

            // Element size defined by Size Factor
            const size = Math.min(viewportW, viewportH) * sizeFactor;
            const scale = 1.8;

            // Calculate Scaled Dimensions for zoomed views
            const zoomScaleX = tlView.scaleX || 1.8; // Use TL as reference
            const zoomScaleY = tlView.scaleY || 1.8;

            const scaledWidth = size * zoomScaleX;
            const scaledHeight = size * zoomScaleY;

            const halfScaledWidth = scaledWidth / 2;
            const halfScaledHeight = scaledHeight / 2;

            const halfViewportW = viewportW / 2;
            const halfViewportH = viewportH / 2;

            // Calculate base offsets (use TL nudge for now, can be per-view)
            const dx = halfScaledWidth - halfViewportW + (tlView.nudgeX || 0);
            const dy = halfScaledHeight - halfViewportH + (tlView.nudgeY || 0);

            // Set CSS Variables for each zoom state
            document.documentElement.style.setProperty('--zoom-x', `${dx}px`);
            document.documentElement.style.setProperty('--zoom-y', `${dy}px`);

            // Zoom Scales - now from config
            document.documentElement.style.setProperty('--zoom-scale-x', zoomScaleX);
            document.documentElement.style.setProperty('--zoom-scale-y', zoomScaleY);

            // Base Scales (for State 0 - Default)
            document.documentElement.style.setProperty('--base-scale-x', HORIZONTAL_SCALE);
            document.documentElement.style.setProperty('--base-scale-y', 1);

            // Update Base Size
            els.wrapper.style.width = `${sizeFactor * 100}vmin`;
            els.wrapper.style.height = `${sizeFactor * 100}vmin`;
        }

        window.addEventListener('resize', updateZoomCalculations);
        // Also call on load
        updateZoomCalculations();


        function scheduleNextZoom() {
            // Determine how long to stay in the CURRENT state before moving to next
            // If current is 0, stay 36s. Else stay 12s.
            const delay = (zoomState === 0) ? 36000 : 12000;

            setTimeout(() => {
                if (!calibrationMode) { // Pause rotation during calibration
                    zoomState = (zoomState + 1) % 5;
                    applyZoomState(zoomState);
                }
                scheduleNextZoom();
            }, delay);
        }

        // Start the loop
        scheduleNextZoom();

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();

            if (key === 'c') {
                calibrationMode = !calibrationMode;
                if (calibrationMode) {
                    overlay.classList.remove('hidden');
                    updateOverlay();
                } else {
                    overlay.classList.add('hidden');
                    // Save
                    localStorage.setItem('crt_config', JSON.stringify(config));
                }
                return;
            }

            // K is for standard toggle (only if not calibrating)
            if (key === 'k' && !calibrationMode) {
                zoomState = (zoomState + 1) % 5;
                applyZoomState(zoomState);
                return;
            }

            if (calibrationMode) {
                const shift = e.shiftKey;
                const STEP_POS = 1; // 1px
                const STEP_SCALE = 0.01;
                const STEP_SIZE = 0.01;

                // Get current view config
                const viewConfig = getCurrentViewConfig();

                switch (e.key) {
                    case 'ArrowUp':
                        if (shift && viewConfig.sizeFactor !== undefined) {
                            viewConfig.sizeFactor += STEP_SIZE;
                        } else {
                            viewConfig.nudgeY = (viewConfig.nudgeY || 0) - STEP_POS;
                        }
                        break;
                    case 'ArrowDown':
                        if (shift && viewConfig.sizeFactor !== undefined) {
                            viewConfig.sizeFactor -= STEP_SIZE;
                        } else {
                            viewConfig.nudgeY = (viewConfig.nudgeY || 0) + STEP_POS;
                        }
                        break;
                    case 'ArrowLeft':
                        if (shift) {
                            viewConfig.scaleX = (viewConfig.scaleX || 1) - STEP_SCALE;
                        } else {
                            viewConfig.nudgeX = (viewConfig.nudgeX || 0) - STEP_POS;
                        }
                        break;
                    case 'ArrowRight':
                        if (shift) {
                            viewConfig.scaleX = (viewConfig.scaleX || 1) + STEP_SCALE;
                        } else {
                            viewConfig.nudgeX = (viewConfig.nudgeX || 0) + STEP_POS;
                        }
                        break;
                }

                // Limits
                if (viewConfig.sizeFactor !== undefined) {
                    if (viewConfig.sizeFactor < 0.1) viewConfig.sizeFactor = 0.1;
                    if (viewConfig.sizeFactor > 1.5) viewConfig.sizeFactor = 1.5;
                }
                if (viewConfig.scaleX < 0.5) viewConfig.scaleX = 0.5;
                if (viewConfig.scaleX > 3.0) viewConfig.scaleX = 3.0;

                updateZoomCalculations();
                updateOverlay();
            }
        });

        function applyZoomState(state) {
            // Remove all zoom classes
            els.wrapper.classList.remove('zoom-tl', 'zoom-tr', 'zoom-br', 'zoom-bl');
            els.bgWrapper.classList.remove('hidden');

            // Recalculate just in case (e.g. mobile orientation change)
            updateZoomCalculations();

            switch (state) {
                case 0:
                    break;
                case 1:
                    els.wrapper.classList.add('zoom-tl');
                    els.bgWrapper.classList.add('hidden');
                    break;
                case 2:
                    els.wrapper.classList.add('zoom-tr');
                    els.bgWrapper.classList.add('hidden');
                    break;
                case 3:
                    els.wrapper.classList.add('zoom-br');
                    els.bgWrapper.classList.add('hidden');
                    break;
                case 4:
                    els.wrapper.classList.add('zoom-bl');
                    els.bgWrapper.classList.add('hidden');
                    break;
            }
        }

        // Fallback image (Dark Gray 1x1 Pixel) to avoid pure black screen if everything fails
        const placeholderImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

        async function fetchTrack() {
            try {
                // 1. Fetch from Last.fm for TEXT ONLY
                const response = await fetch(URL);
                const data = await response.json();

                if (!data.recenttracks || !data.recenttracks.track || data.recenttracks.track.length === 0) {
                    throw new Error('No track data found');
                }

                const track = data.recenttracks.track[0];
                const trackName = track.name;
                const artistName = track.artist['#text'];
                const albumName = track.album ? track.album['#text'] : '';
                const mbid = track.album ? track.album.mbid : null; // MusicBrainz ID

                // create unique ID for cache
                const trackId = `${artistName}-${trackName}-${albumName}`;

                // 2. Check Cache
                if (trackId === CACHE.id) {
                    return; // Same track, do nothing
                }

                CACHE.id = trackId;

                // 3. Fetch from iTunes for IMAGE ONLY
                let imageUrl = await fetchItunesArtwork(artistName, trackName, albumName);

                // 4. Fallback: MusicBrainz (Cover Art Archive)
                if (!imageUrl && mbid) {
                    try {
                        const mbUrl = `https://coverartarchive.org/release/${mbid}/front`;
                        const mbTest = await fetch(mbUrl, { method: 'HEAD' });
                        if (mbTest.ok) {
                            imageUrl = mbUrl;
                        }
                    } catch (e) {
                        console.warn('MusicBrainz fetch failed', e);
                    }
                }

                if (imageUrl) {
                    updateUI(imageUrl);
                } else {
                    // Fallback local gradient if everything fails
                    updateUI(placeholderImg);
                }

            } catch (error) {
                console.error('Error fetching data:', error);
                // Do not update UI on error, keep last valid state
            }
        }

        async function fetchItunesArtwork(artist, track, lastFmAlbum) {

            // Helper to clean query strings (Musicbrainz/Last.fm often have junk)
            const cleanQuery = (str) => {
                if (!str) return '';
                return str
                    .replace(/\s*\(.*?\)\s*/g, '') // Remove (...)
                    .replace(/\s*\[.*?\]\s*/g, '') // Remove [...]
                    .replace(/ - .*/, '') // Remove " - Remastered" etc
                    .replace(/Remastered/i, '')
                    .replace(/Deluxe/i, '')
                    .replace(/Edition/i, '')
                    .trim();
            };

            // Helper to execute search and filter
            const executeSearch = async (term, entity) => {
                try {
                    const itunesUrl = `https://itunes.apple.com/search?term=${term}&media=music&entity=${entity}&limit=25`;
                    const response = await fetch(itunesUrl);
                    const data = await response.json();

                    if (!data.results || data.results.length === 0) return null;
                    return filterItunesResults(data.results, artist, lastFmAlbum);
                } catch (e) {
                    console.warn(`iTunes search failed for ${entity}`, e);
                    return null;
                }
            };

            // Strategy 1: Search by Album (Preferred)
            if (lastFmAlbum) {
                // Search with CLEANED album name first for better hit rate
                const cleanedAlbum = cleanQuery(lastFmAlbum);
                const query = encodeURIComponent(`${artist} ${cleanedAlbum}`);
                const result = await executeSearch(query, 'album');
                if (result) return result;

                // If cleaned failed, maybe try raw? No, raw usually fails if cleaned failed.
                console.log("Album search failed, falling back to track search...");
            }

            // Strategy 2: Search by Track (Fallback)
            const query = encodeURIComponent(`${artist} ${track}`);
            return await executeSearch(query, 'song');
        }

        function filterItunesResults(results, targetArtistName, targetAlbumName) {
            // Enhanced Normalization
            const normalize = (str) => {
                if (!str) return '';
                return str.toLowerCase()
                    .replace(/^the\s+/, '')
                    .replace(/['".,\/#!$%\^&\*;:{}=\-_`~()]/g, "")
                    .replace(/\s+/g, "");
            };

            const targetArtist = normalize(targetArtistName);
            const targetAlbum = normalize(targetAlbumName);

            // 1. HARD Filters (Reject these ALWAYS unless target matches them)
            const hardKeywords = ['greatest', 'bestof', 'hits', 'collection', 'anthology', 'essentials'];

            // 2. SOFT Filters (Prefer standard, but accept these if needed)
            const softKeywords = ['deluxe', 'expanded', 'remastered', 'anniversary', 'edition'];

            const targetHasHard = hardKeywords.some(kw => targetAlbum.includes(kw));

            // Best match candidates
            let exactMatch = null;
            let softMatch = null;
            let validResults = []; // For partial matches and general candidates

            for (const result of results) {
                if (!result.artworkUrl100) continue;

                // Strict Artist Check
                if (normalize(result.artistName) !== targetArtist) {
                    continue;
                }

                const resAlbum = normalize(result.collectionName);

                // 1. Check for Exact Album Match
                if (resAlbum === targetAlbum) {
                    exactMatch = result;
                    break;
                }

                // 2. Hard Filter: If target doesn't have "Greatest", reject "Greatest"
                if (!targetHasHard) {
                    const isHard = hardKeywords.some(kw => resAlbum.includes(kw));
                    if (isHard) continue; // Hard Reject
                }

                // 3. Soft Filter
                const isSoft = softKeywords.some(kw => resAlbum.includes(kw));
                if (targetAlbum && !targetAlbum.includes(resAlbum) && isSoft) {
                    if (!softMatch) softMatch = result; // Keep first acceptable soft match
                    continue;
                }

                // If not an exact match and passed hard/soft filters, add to valid candidates
                validResults.push(result);
            }

            let finalResult = exactMatch;

            if (!finalResult) {
                // Try to find a partial match in validResults
                const partialMatch = validResults.find(res => normalize(res.collectionName).includes(targetAlbum));

                if (partialMatch) {
                    finalResult = partialMatch;
                } else if (validResults.length > 0) {
                    // If we have results that aren't "Greatest Hits" and aren't "Deluxe", use first one
                    finalResult = validResults[0];
                } else if (softMatch) {
                    // If we only found a "Deluxe" version and we have no other options, USE IT.
                    finalResult = softMatch;
                }
            }

            if (finalResult && finalResult.artworkUrl100) {
                return finalResult.artworkUrl100.replace('100x100bb', '500x500bb');
            }

            return null;
        }

        function updateUI(img) {
            // Remove loading screen on first successful load
            if (!els.loading.classList.contains('hidden')) {
                els.loading.classList.add('hidden');
            }

            // Only update if image actually changed
            if (img !== CACHE.image) {
                CACHE.image = img;

                // Identify layers
                const currentIdx = activeLayerIndex;
                const nextIdx = (activeLayerIndex + 1) % 2;

                const nextBg = els.bgLayers[nextIdx];
                const currentBg = els.bgLayers[currentIdx];

                const nextArt = els.artLayers[nextIdx];
                const currentArt = els.artLayers[currentIdx];

                // Preload Image
                const tempImg = new Image();
                tempImg.src = img;

                tempImg.onload = () => {
                    // 1. Prepare Next Layer (Hidden, but above current)
                    // We want Next to fade IN over current.
                    // Current is z-index 1 (or 2). Next should be z-index 3.
                    // Actually, let's keep it simple.
                    // Current is visible. Next is hidden.
                    // Move Next to Top (zIndex 2). Current at Bottom (zIndex 1).

                    nextBg.style.backgroundImage = `url('${img}')`;
                    nextArt.src = img;

                    // Ensure opacity starts at 0
                    nextBg.style.opacity = 0;
                    nextArt.style.opacity = 0;

                    // Move to Top
                    nextBg.style.zIndex = 2;
                    nextArt.style.zIndex = 2;

                    // Move Current to Bottom (but still visible 100% opacity)
                    currentBg.style.zIndex = 1;
                    currentArt.style.zIndex = 1;

                    // Force reflow
                    void nextArt.offsetWidth;

                    // 2. Fade In Next Layer
                    nextBg.style.opacity = 1;
                    nextArt.style.opacity = 1;

                    // 3. Update State
                    activeLayerIndex = nextIdx;

                    // 4. Cleanup Old Layer after transition
                    // Wait for transition duration (fade-speed varies but let's assume 1s or read var)
                    // --fade-speed default is 1s? Let's give it 1.2s to be safe.
                    setTimeout(() => {
                        currentBg.style.opacity = 0;
                        currentArt.style.opacity = 0;

                        // Garbage Collection on temp
                        tempImg.onload = null;
                        tempImg.src = '';
                    }, 1500);
                };
            }
        }

        // Initial call
        fetchTrack();

        // Poll every 10 seconds (Throttled for stability)
        setInterval(fetchTrack, 10000);

        // Kiosk Mode Safety: Reload page every 4 hours to clear memory
        setTimeout(() => {
            window.location.reload();
        }, 4 * 60 * 60 * 1000); // 4 hours

        // Show hint briefly
        setTimeout(() => {
            const hint = document.getElementById('calibration-hint');
            hint.style.opacity = 1;
            setTimeout(() => {
                hint.style.opacity = 0;
            }, 5000);
        }, 2000);

    </script>
</body>

</html>