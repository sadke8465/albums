<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Now Playing | Noamsadi95</title>
    <style>
        :root {
            --transition-speed: 10s;
            /* Zoom speed (kept as user req) */
            --zoom-curve: cubic-bezier(0.7, 0, 0.3, 1);
            --fade-speed: 1.5s;
            --fade-curve: cubic-bezier(0.4, 0, 0.2, 1);
            /* Nice smooth curve */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #111;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Ambient Background */
        #ambient-bg {
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            background-size: cover;
            background-position: center;
            filter: blur(80px) brightness(0.7);
            z-index: -1;
            /* We need to transition opacity for hiding via zoom AND for album change.
               We can use comma separated transitions if needed, but here simple opacity is fine.
               User wants "curved fading animation". */
            transition: opacity var(--fade-speed) var(--fade-curve);
            transform: scale(1.1);
            opacity: 1;
            will-change: opacity;
            /* GPU Hint */
        }

        #ambient-bg.hidden {
            opacity: 0;
            transition: opacity var(--transition-speed) var(--zoom-curve);
            /* Use zoom speed when hiding for zoom */
        }

        #ambient-bg.fade-out {
            opacity: 0;
        }

        /* Container */
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* Album Art */
        .album-art-wrapper {
            width: 85vmin;
            height: 85vmin;
            max-width: 85vw;
            max-height: 85vh;
            border-radius: 7px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform-origin: center center;
            transition: transform var(--transition-speed) var(--zoom-curve), border-radius var(--transition-speed) var(--zoom-curve);
            will-change: transform, border-radius;
            /* GPU Hint */
        }

        /* Zoom States */
        /* 
           Logic: Align Album Corner to Screen Corner exactly.
           Scale reduced to 1.8 (Requested "A bit less zoom").
           Half Scaled Width = 85vmin * 1.8 / 2 = 76.5vmin
           
           TL: Move Right/Down to bring TL corner to 0,0
           TranslateX = 76.5vmin - 50vw
           TranslateY = 76.5vmin - 50vh
        */
        .album-art-wrapper.zoom-tl {
            transform: translate(calc(76.5vmin - 50vw), calc(76.5vmin - 50vh)) scale(1.8);
        }

        .album-art-wrapper.zoom-tr {
            transform: translate(calc(50vw - 76.5vmin), calc(76.5vmin - 50vh)) scale(1.8);
        }

        .album-art-wrapper.zoom-br {
            transform: translate(calc(50vw - 76.5vmin), calc(50vh - 76.5vmin)) scale(1.8);
        }

        .album-art-wrapper.zoom-bl {
            transform: translate(calc(76.5vmin - 50vw), calc(50vh - 76.5vmin)) scale(1.8);
        }

        /* Remove radius when zoomed to look like full bleed image */
        .album-art-wrapper[class*="zoom-"] {
            border-radius: 0;
        }

        #album-art {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: inherit;
            opacity: 1;
            transition: opacity var(--fade-speed) var(--fade-curve);
            will-change: opacity;
            /* GPU Hint */
        }

        #album-art.fade-out {
            opacity: 0;
        }

        /* Loading State */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 3px solid #FFF;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        .loader::after {
            content: '';
            box-sizing: border-box;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-bottom-color: #FF3D00;
        }

        @keyframes rotation {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div class="loading" id="loading-screen">
        <span class="loader"></span>
    </div>

    <div id="ambient-bg"></div>

    <div class="container">
        <div class="album-art-wrapper">
            <img id="album-art" src="" alt="Album Art">
        </div>
    </div>

    <script>
        const API_KEY = 'f12a1d5a9aad4c0d570403a0aabc9f61';
        const USERNAME = 'Noamsadi95';
        const URL = `https://ws.audioscrobbler.com/2.0/?method=user.getRecentTracks&user=${USERNAME}&api_key=${API_KEY}&format=json&limit=1`;

        const CACHE = {
            id: null, // Artist + Track string
            image: null
        };

        let zoomState = 0; // 0: Default, 1: TL, 2: TR, 3: BR, 4: BL

        const els = {
            bg: document.getElementById('ambient-bg'),
            art: document.getElementById('album-art'),
            wrapper: document.querySelector('.album-art-wrapper'),
            loading: document.getElementById('loading-screen')
        };

        // Zoom Logic
        // Automatically advance. 
        // Logic: 12s for quadrants (states 1-4), 36s for full album (state 0).

        function scheduleNextZoom() {
            // Determine how long to stay in the CURRENT state before moving to next
            // If current is 0, stay 36s. Else stay 12s.
            const delay = (zoomState === 0) ? 36000 : 12000;

            setTimeout(() => {
                zoomState = (zoomState + 1) % 5;
                applyZoomState(zoomState);
                scheduleNextZoom();
            }, delay);
        }

        // Start the loop
        scheduleNextZoom();

        function applyZoomState(state) {
            // Remove all zoom classes
            els.wrapper.classList.remove('zoom-tl', 'zoom-tr', 'zoom-br', 'zoom-bl');
            els.bg.classList.remove('hidden');

            switch (state) {
                case 0:
                    // Default logic handles this (removal of classes)
                    break;
                case 1:
                    els.wrapper.classList.add('zoom-tl');
                    els.bg.classList.add('hidden');
                    break;
                case 2:
                    els.wrapper.classList.add('zoom-tr');
                    els.bg.classList.add('hidden');
                    break;
                case 3:
                    els.wrapper.classList.add('zoom-br');
                    els.bg.classList.add('hidden');
                    break;
                case 4:
                    els.wrapper.classList.add('zoom-bl');
                    els.bg.classList.add('hidden');
                    break;
            }
        }

        // Fallback image (Dark Gray 1x1 Pixel) to avoid pure black screen if everything fails
        const placeholderImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

        async function fetchTrack() {
            try {
                // 1. Fetch from Last.fm for TEXT ONLY
                const response = await fetch(URL);
                const data = await response.json();

                if (!data.recenttracks || !data.recenttracks.track || data.recenttracks.track.length === 0) {
                    throw new Error('No track data found');
                }

                const track = data.recenttracks.track[0];
                const trackName = track.name;
                const artistName = track.artist['#text'];
                const albumName = track.album ? track.album['#text'] : '';
                const mbid = track.album ? track.album.mbid : null; // MusicBrainz ID

                // create unique ID for cache
                const trackId = `${artistName}-${trackName}-${albumName}`;

                // 2. Check Cache
                if (trackId === CACHE.id) {
                    return; // Same track, do nothing
                }

                CACHE.id = trackId;

                // 3. Fetch from iTunes for IMAGE ONLY
                let imageUrl = await fetchItunesArtwork(artistName, trackName, albumName);

                // 4. Fallback: MusicBrainz (Cover Art Archive)
                if (!imageUrl && mbid) {
                    try {
                        const mbUrl = `https://coverartarchive.org/release/${mbid}/front`;
                        const mbTest = await fetch(mbUrl, { method: 'HEAD' });
                        if (mbTest.ok) {
                            imageUrl = mbUrl;
                        }
                    } catch (e) {
                        console.warn('MusicBrainz fetch failed', e);
                    }
                }

                if (imageUrl) {
                    updateUI(imageUrl);
                } else {
                    // Fallback local gradient if everything fails
                    updateUI(placeholderImg);
                }

            } catch (error) {
                console.error('Error fetching data:', error);
                // Do not update UI on error, keep last valid state
            }
        }

        async function fetchItunesArtwork(artist, track, lastFmAlbum) {
            try {
                const query = encodeURIComponent(`${artist} ${track}`);
                // Limit increased to 25 to find correct album
                const itunesUrl = `https://itunes.apple.com/search?term=${query}&media=music&entity=song&limit=25`;

                const response = await fetch(itunesUrl);
                const data = await response.json();

                if (!data.results || data.results.length === 0) {
                    return null;
                }

                // Enhanced Normalization: remove 'the', punctuation, spaces, lowercase
                const normalize = (str) => {
                    if (!str) return '';
                    return str.toLowerCase()
                        .replace(/^the\s+/, '') // Remove leading "The "
                        .replace(/['".,\/#!$%\^&\*;:{}=\-_`~()]/g, "") // punctuation
                        .replace(/\s+/g, ""); // spaces
                };

                const targetAlbum = normalize(lastFmAlbum);
                const targetArtist = normalize(artist);

                // 1. HARD Filters (Reject these ALWAYS unless target matches them)
                const hardKeywords = ['greatest', 'bestof', 'hits', 'collection', 'anthology', 'essentials'];

                // 2. SOFT Filters (Prefer standard, but accept these if needed)
                const softKeywords = ['deluxe', 'expanded', 'remastered', 'anniversary', 'edition'];

                const targetHasHard = hardKeywords.some(kw => targetAlbum.includes(kw));
                // const targetHasSoft = softKeywords.some(kw => targetAlbum.includes(kw)); // Unused, we use logic below.

                // Filter Loop
                let validResults = [];
                let exactMatch = null;
                let softMatch = null; // Matches that failed soft filter but passed hard filter

                for (const result of data.results) {
                    if (!result.artworkUrl100) continue;

                    // Strict Artist Check
                    if (normalize(result.artistName) !== targetArtist) {
                        continue;
                    }

                    const resAlbum = normalize(result.collectionName);

                    // 1. Check for Exact Album Match
                    if (resAlbum === targetAlbum) {
                        exactMatch = result;
                        break;
                    }

                    // 2. Hard Filter: If target doesn't have "Greatest", reject "Greatest"
                    if (!targetHasHard) {
                        const isHard = hardKeywords.some(kw => resAlbum.includes(kw));
                        if (isHard) continue; // Hard Reject
                    }

                    // 3. Soft Filter
                    const isSoft = softKeywords.some(kw => resAlbum.includes(kw));
                    if (!targetAlbum.includes(resAlbum) && isSoft) {
                        // It has a soft keyword (Deluxe) that target doesn't. 
                        // Store it as a fallback, but don't add to main 'validResults' which implies strict adherence?
                        // Or add to validResults but we prioritize exactMatch.
                        if (!softMatch) softMatch = result; // Keep the first acceptable soft match
                        continue; // Don't treat as "primary" valid candidate yet
                    }

                    validResults.push(result);
                }

                // Decision Logic
                let finalResult = exactMatch;

                if (!finalResult) {
                    // Try to find a partial match in validResults
                    // e.g. Target: "Album" | Res: "The Album" (normalized to "album") -> caught by exactMatch
                    // e.g. Target: "Album" | Res: "Album [UK Version]" -> validResult
                    const partialMatch = validResults.find(res => normalize(res.collectionName).includes(targetAlbum));

                    if (partialMatch) {
                        finalResult = partialMatch;
                    } else if (validResults.length > 0) {
                        // If we have results that aren't "Greatest Hits" and aren't "Deluxe", use first one?
                        finalResult = validResults[0];
                    } else if (softMatch) {
                        // If we only found a "Deluxe" version and we have no other options, USE IT.
                        // This prevents the black screen for "Deluxe Only" albums.
                        finalResult = softMatch;
                    }
                }

                if (finalResult && finalResult.artworkUrl100) {
                    return finalResult.artworkUrl100.replace('100x100bb', '500x500bb');
                }

                return null;

            } catch (e) {
                console.warn('iTunes fetch failed', e);
                return null;
            }
        }

        function updateUI(img) {
            // Remove loading screen on first successful load
            if (!els.loading.classList.contains('hidden')) {
                els.loading.classList.add('hidden');
            }

            // Only update if image actually changed (redundant check but safe)
            if (img !== CACHE.image) {

                CACHE.image = img;

                // Fade Out
                els.art.classList.add('fade-out');

                // Only fade BG if it's currently visible (not in zoom mode)
                els.bg.classList.add('fade-out');

                // Wait for fade out
                setTimeout(() => {
                    // Update Sources
                    const tempImg = new Image();
                    tempImg.src = img;

                    tempImg.onload = () => {
                        els.art.src = img;
                        els.bg.style.backgroundImage = `url('${img}')`;

                        // Force reflow/repaint
                        void els.art.offsetWidth;

                        // Fade In
                        els.art.classList.remove('fade-out');
                        els.art.classList.add('loaded'); // Ensure loaded class is present if used

                        els.bg.classList.remove('fade-out');

                        // Garbage Collection Help
                        tempImg.onload = null;
                        tempImg.src = '';
                    };
                }, 1500);
            }
        }

        // Initial call
        fetchTrack();

        // Poll every 10 seconds (Throttled for stability)
        setInterval(fetchTrack, 10000);

        // Kiosk Mode Safety: Reload page every 4 hours to clear memory
        setTimeout(() => {
            window.location.reload();
        }, 4 * 60 * 60 * 1000); // 4 hours

    </script>
</body>

</html>