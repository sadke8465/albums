<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Now Playing | Noamsadi95</title>
    <style>
        :root {
            --transition-speed: 10s;
            /* Zoom speed (kept as user req) */
            --zoom-curve: cubic-bezier(0.7, 0, 0.3, 1);
            --fade-speed: 1.5s;
            --fade-curve: cubic-bezier(0.4, 0, 0.2, 1);
            /* Nice smooth curve */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #111;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Ambient Background Wrapper */
        #ambient-bg {
            position: absolute;
            top: -10%;
            left: -10%;
            width: 120%;
            height: 120%;
            z-index: -1;
            /* Container scales */
            transform: scale(1.1);
        }

        /* Background Layers */
        .bg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: blur(80px) brightness(0.7);
            opacity: 0;
            transition: opacity var(--fade-speed) var(--fade-curve);
            will-change: opacity;
        }

        #ambient-bg.hidden {
            /* Hide the whole container during zoom out if needed, 
                but logic says we only hide bg when zoomed IN. */
            opacity: 0;
            transition: opacity var(--transition-speed) var(--zoom-curve);
        }

        /* Container */
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* Album Art */
        .album-art-wrapper {
            width: 85vmin;
            height: 85vmin;
            max-width: 85vw;
            max-height: 85vh;
            border-radius: 7px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform-origin: center center;
            transition: transform var(--transition-speed) var(--zoom-curve), border-radius var(--transition-speed) var(--zoom-curve);
            will-change: transform, border-radius;
            /* Relative positioning for children absolute */
            position: relative;
            background: #000;

            /* Apply Base Scale (Correction for CRT) */
            /* Default transform is scale(1.33, 1) to widen image */
            transform: scale(var(--base-scale-x, 1), var(--base-scale-y, 1));
        }

        /* Zoom States */
        /* 
           Logic: Align Album Corner to Screen Corner exactly.
           Variables --zoom-x and --zoom-y are calculated in JS.
           
           TL: Move Right/Down (+x, +y)
           TR: Move Left/Down (-x, +y)
           BR: Move Left/Up (-x, -y)
           BL: Move Right/Up (+x, -y)
        */
        .album-art-wrapper.zoom-tl {
            transform: translate(var(--zoom-x), var(--zoom-y)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        .album-art-wrapper.zoom-tr {
            transform: translate(calc(var(--zoom-x) * -1), var(--zoom-y)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        .album-art-wrapper.zoom-br {
            transform: translate(calc(var(--zoom-x) * -1), calc(var(--zoom-y) * -1)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        .album-art-wrapper.zoom-bl {
            transform: translate(var(--zoom-x), calc(var(--zoom-y) * -1)) scale(var(--zoom-scale-x), var(--zoom-scale-y));
        }

        /* Remove radius when zoomed to look like full bleed image */
        .album-art-wrapper[class*="zoom-"] {
            border-radius: 0;
        }

        .art-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: inherit;
            opacity: 0;
            transition: opacity var(--fade-speed) var(--fade-curve);
            will-change: opacity;
        }

        /* Loading State */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 48px;
            height: 48px;
            border: 3px solid #FFF;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        .loader::after {
            content: '';
            box-sizing: border-box;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-bottom-color: #FF3D00;
        }

        @keyframes rotation {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>

    <div class="loading" id="loading-screen">
        <span class="loader"></span>
    </div>

    <div id="ambient-bg">
        <div id="bg-layer-0" class="bg-layer"></div>
        <div id="bg-layer-1" class="bg-layer"></div>
    </div>

    <div class="container">
        <div class="album-art-wrapper">
            <img id="art-layer-0" class="art-layer" src="" alt="Album Art">
            <img id="art-layer-1" class="art-layer" src="" alt="Album Art">
        </div>
    </div>

    <script>
        const API_KEY = 'f12a1d5a9aad4c0d570403a0aabc9f61';
        const USERNAME = 'Noamsadi95';
        const URL = `https://ws.audioscrobbler.com/2.0/?method=user.getRecentTracks&user=${USERNAME}&api_key=${API_KEY}&format=json&limit=1`;

        const CACHE = {
            id: null, // Artist + Track string
            image: null
        };

        let zoomState = 0; // 0: Default, 1: TL, 2: TR, 3: BR, 4: BL

        const els = {
            bgWrapper: document.getElementById('ambient-bg'),
            bgLayers: [
                document.getElementById('bg-layer-0'),
                document.getElementById('bg-layer-1')
            ],
            wrapper: document.querySelector('.album-art-wrapper'),
            artLayers: [
                document.getElementById('art-layer-0'),
                document.getElementById('art-layer-1')
            ],
            loading: document.getElementById('loading-screen')
        };

        // State for Dual Buffering
        let activeLayerIndex = 0; // The layer currently visible (opacity 1)

        // Init: Ensure layer 0 is top
        if (els.bgLayers[0] && els.artLayers[0]) {
            els.bgLayers[0].style.zIndex = 2;
            els.bgLayers[1].style.zIndex = 1;
            els.artLayers[0].style.zIndex = 2;
            els.artLayers[1].style.zIndex = 1;
        }

        // Zoom Logic
        // Automatically advance. 
        // Logic: 12s for quadrants (states 1-4), 36s for full album (state 0).

        // CSS Variables for Zoom
        function updateZoomCalculations() {
            const viewportW = window.innerWidth;
            const viewportH = window.innerHeight;

            // Configuration for CRT Correction
            const HORIZONTAL_SCALE = 1.33; // Stretch width to correct 4:3 squeeze
            const NUDGE_X = 0; // Manual X offset (px)
            const NUDGE_Y = 0; // Manual Y offset (px)

            // Element size is 85vmin.
            const size = Math.min(viewportW, viewportH) * 0.85;
            const scale = 1.8;

            // Calculate Scaled Dimensions
            // We apply Horizontal Scale to Width ONLY
            const scaledWidth = size * scale * HORIZONTAL_SCALE;
            const scaledHeight = size * scale;

            const halfScaledWidth = scaledWidth / 2;
            const halfScaledHeight = scaledHeight / 2;

            const halfViewportW = viewportW / 2;
            const halfViewportH = viewportH / 2;

            // Calculate offsets to move corner to corner
            const dx = halfScaledWidth - halfViewportW + NUDGE_X;
            const dy = halfScaledHeight - halfViewportH + NUDGE_Y;

            // Set CSS Variables
            document.documentElement.style.setProperty('--zoom-x', `${dx}px`);
            document.documentElement.style.setProperty('--zoom-y', `${dy}px`);

            // Zoom Scales
            document.documentElement.style.setProperty('--zoom-scale-x', scale * HORIZONTAL_SCALE);
            document.documentElement.style.setProperty('--zoom-scale-y', scale);

            // Base Scales (for State 0)
            document.documentElement.style.setProperty('--base-scale-x', 1 * HORIZONTAL_SCALE);
            document.documentElement.style.setProperty('--base-scale-y', 1);
        }

        window.addEventListener('resize', updateZoomCalculations);
        // Also call on load
        updateZoomCalculations();


        function scheduleNextZoom() {
            // Determine how long to stay in the CURRENT state before moving to next
            // If current is 0, stay 36s. Else stay 12s.
            const delay = (zoomState === 0) ? 36000 : 12000;

            setTimeout(() => {
                zoomState = (zoomState + 1) % 5;
                applyZoomState(zoomState);
                scheduleNextZoom();
            }, delay);
        }

        // Start the loop
        scheduleNextZoom();

        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'k') {
                zoomState = (zoomState + 1) % 5;
                applyZoomState(zoomState);
            }
        });

        function applyZoomState(state) {
            // Remove all zoom classes
            els.wrapper.classList.remove('zoom-tl', 'zoom-tr', 'zoom-br', 'zoom-bl');
            els.bgWrapper.classList.remove('hidden');

            // Recalculate just in case (e.g. mobile orientation change)
            updateZoomCalculations();

            switch (state) {
                case 0:
                    break;
                case 1:
                    els.wrapper.classList.add('zoom-tl');
                    els.bgWrapper.classList.add('hidden');
                    break;
                case 2:
                    els.wrapper.classList.add('zoom-tr');
                    els.bgWrapper.classList.add('hidden');
                    break;
                case 3:
                    els.wrapper.classList.add('zoom-br');
                    els.bgWrapper.classList.add('hidden');
                    break;
                case 4:
                    els.wrapper.classList.add('zoom-bl');
                    els.bgWrapper.classList.add('hidden');
                    break;
            }
        }

        // Fallback image (Dark Gray 1x1 Pixel) to avoid pure black screen if everything fails
        const placeholderImg = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

        async function fetchTrack() {
            try {
                // 1. Fetch from Last.fm for TEXT ONLY
                const response = await fetch(URL);
                const data = await response.json();

                if (!data.recenttracks || !data.recenttracks.track || data.recenttracks.track.length === 0) {
                    throw new Error('No track data found');
                }

                const track = data.recenttracks.track[0];
                const trackName = track.name;
                const artistName = track.artist['#text'];
                const albumName = track.album ? track.album['#text'] : '';
                const mbid = track.album ? track.album.mbid : null; // MusicBrainz ID

                // create unique ID for cache
                const trackId = `${artistName}-${trackName}-${albumName}`;

                // 2. Check Cache
                if (trackId === CACHE.id) {
                    return; // Same track, do nothing
                }

                CACHE.id = trackId;

                // 3. Fetch from iTunes for IMAGE ONLY
                let imageUrl = await fetchItunesArtwork(artistName, trackName, albumName);

                // 4. Fallback: MusicBrainz (Cover Art Archive)
                if (!imageUrl && mbid) {
                    try {
                        const mbUrl = `https://coverartarchive.org/release/${mbid}/front`;
                        const mbTest = await fetch(mbUrl, { method: 'HEAD' });
                        if (mbTest.ok) {
                            imageUrl = mbUrl;
                        }
                    } catch (e) {
                        console.warn('MusicBrainz fetch failed', e);
                    }
                }

                if (imageUrl) {
                    updateUI(imageUrl);
                } else {
                    // Fallback local gradient if everything fails
                    updateUI(placeholderImg);
                }

            } catch (error) {
                console.error('Error fetching data:', error);
                // Do not update UI on error, keep last valid state
            }
        }

        async function fetchItunesArtwork(artist, track, lastFmAlbum) {

            // Helper to clean query strings (Musicbrainz/Last.fm often have junk)
            const cleanQuery = (str) => {
                if (!str) return '';
                return str
                    .replace(/\s*\(.*?\)\s*/g, '') // Remove (...)
                    .replace(/\s*\[.*?\]\s*/g, '') // Remove [...]
                    .replace(/ - .*/, '') // Remove " - Remastered" etc
                    .replace(/Remastered/i, '')
                    .replace(/Deluxe/i, '')
                    .replace(/Edition/i, '')
                    .trim();
            };

            // Helper to execute search and filter
            const executeSearch = async (term, entity) => {
                try {
                    const itunesUrl = `https://itunes.apple.com/search?term=${term}&media=music&entity=${entity}&limit=25`;
                    const response = await fetch(itunesUrl);
                    const data = await response.json();

                    if (!data.results || data.results.length === 0) return null;
                    return filterItunesResults(data.results, artist, lastFmAlbum);
                } catch (e) {
                    console.warn(`iTunes search failed for ${entity}`, e);
                    return null;
                }
            };

            // Strategy 1: Search by Album (Preferred)
            if (lastFmAlbum) {
                // Search with CLEANED album name first for better hit rate
                const cleanedAlbum = cleanQuery(lastFmAlbum);
                const query = encodeURIComponent(`${artist} ${cleanedAlbum}`);
                const result = await executeSearch(query, 'album');
                if (result) return result;

                // If cleaned failed, maybe try raw? No, raw usually fails if cleaned failed.
                console.log("Album search failed, falling back to track search...");
            }

            // Strategy 2: Search by Track (Fallback)
            const query = encodeURIComponent(`${artist} ${track}`);
            return await executeSearch(query, 'song');
        }

        function filterItunesResults(results, targetArtistName, targetAlbumName) {
            // Enhanced Normalization
            const normalize = (str) => {
                if (!str) return '';
                return str.toLowerCase()
                    .replace(/^the\s+/, '')
                    .replace(/['".,\/#!$%\^&\*;:{}=\-_`~()]/g, "")
                    .replace(/\s+/g, "");
            };

            const targetArtist = normalize(targetArtistName);
            const targetAlbum = normalize(targetAlbumName);

            // 1. HARD Filters (Reject these ALWAYS unless target matches them)
            const hardKeywords = ['greatest', 'bestof', 'hits', 'collection', 'anthology', 'essentials'];

            // 2. SOFT Filters (Prefer standard, but accept these if needed)
            const softKeywords = ['deluxe', 'expanded', 'remastered', 'anniversary', 'edition'];

            const targetHasHard = hardKeywords.some(kw => targetAlbum.includes(kw));

            // Best match candidates
            let exactMatch = null;
            let softMatch = null;
            let validResults = []; // For partial matches and general candidates

            for (const result of results) {
                if (!result.artworkUrl100) continue;

                // Strict Artist Check
                if (normalize(result.artistName) !== targetArtist) {
                    continue;
                }

                const resAlbum = normalize(result.collectionName);

                // 1. Check for Exact Album Match
                if (resAlbum === targetAlbum) {
                    exactMatch = result;
                    break;
                }

                // 2. Hard Filter: If target doesn't have "Greatest", reject "Greatest"
                if (!targetHasHard) {
                    const isHard = hardKeywords.some(kw => resAlbum.includes(kw));
                    if (isHard) continue; // Hard Reject
                }

                // 3. Soft Filter
                const isSoft = softKeywords.some(kw => resAlbum.includes(kw));
                if (targetAlbum && !targetAlbum.includes(resAlbum) && isSoft) {
                    if (!softMatch) softMatch = result; // Keep first acceptable soft match
                    continue;
                }

                // If not an exact match and passed hard/soft filters, add to valid candidates
                validResults.push(result);
            }

            let finalResult = exactMatch;

            if (!finalResult) {
                // Try to find a partial match in validResults
                const partialMatch = validResults.find(res => normalize(res.collectionName).includes(targetAlbum));

                if (partialMatch) {
                    finalResult = partialMatch;
                } else if (validResults.length > 0) {
                    // If we have results that aren't "Greatest Hits" and aren't "Deluxe", use first one
                    finalResult = validResults[0];
                } else if (softMatch) {
                    // If we only found a "Deluxe" version and we have no other options, USE IT.
                    finalResult = softMatch;
                }
            }

            if (finalResult && finalResult.artworkUrl100) {
                return finalResult.artworkUrl100.replace('100x100bb', '500x500bb');
            }

            return null;
        }

        function updateUI(img) {
            // Remove loading screen on first successful load
            if (!els.loading.classList.contains('hidden')) {
                els.loading.classList.add('hidden');
            }

            // Only update if image actually changed
            if (img !== CACHE.image) {
                CACHE.image = img;

                // Identify layers
                const currentIdx = activeLayerIndex;
                const nextIdx = (activeLayerIndex + 1) % 2;

                const nextBg = els.bgLayers[nextIdx];
                const currentBg = els.bgLayers[currentIdx];

                const nextArt = els.artLayers[nextIdx];
                const currentArt = els.artLayers[currentIdx];

                // Preload Image
                const tempImg = new Image();
                tempImg.src = img;

                tempImg.onload = () => {
                    // 1. Prepare Next Layer (Hidden, but above current)
                    // We want Next to fade IN over current.
                    // Current is z-index 1 (or 2). Next should be z-index 3.
                    // Actually, let's keep it simple.
                    // Current is visible. Next is hidden.
                    // Move Next to Top (zIndex 2). Current at Bottom (zIndex 1).

                    nextBg.style.backgroundImage = `url('${img}')`;
                    nextArt.src = img;

                    // Ensure opacity starts at 0
                    nextBg.style.opacity = 0;
                    nextArt.style.opacity = 0;

                    // Move to Top
                    nextBg.style.zIndex = 2;
                    nextArt.style.zIndex = 2;

                    // Move Current to Bottom (but still visible 100% opacity)
                    currentBg.style.zIndex = 1;
                    currentArt.style.zIndex = 1;

                    // Force reflow
                    void nextArt.offsetWidth;

                    // 2. Fade In Next Layer
                    nextBg.style.opacity = 1;
                    nextArt.style.opacity = 1;

                    // 3. Update State
                    activeLayerIndex = nextIdx;

                    // 4. Cleanup Old Layer after transition
                    // Wait for transition duration (fade-speed varies but let's assume 1s or read var)
                    // --fade-speed default is 1s? Let's give it 1.2s to be safe.
                    setTimeout(() => {
                        currentBg.style.opacity = 0;
                        currentArt.style.opacity = 0;

                        // Garbage Collection on temp
                        tempImg.onload = null;
                        tempImg.src = '';
                    }, 1500);
                };
            }
        }

        // Initial call
        fetchTrack();

        // Poll every 10 seconds (Throttled for stability)
        setInterval(fetchTrack, 10000);

        // Kiosk Mode Safety: Reload page every 4 hours to clear memory
        setTimeout(() => {
            window.location.reload();
        }, 4 * 60 * 60 * 1000); // 4 hours

    </script>
</body>

</html>